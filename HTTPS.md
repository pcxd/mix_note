# HTTPS


## 消息摘要：
    消息摘要（Message Digest），又称数字摘要（Digital Digest）或数字指纹（Finger Print）。
    
- 消息摘要就是在消息数据上，执行一个单向的Hash函数，生成一个固定长度的Hash值，这个Hash值即是消息摘要。
- 消息摘要函数是单向函数，即只能进行正向的信息摘要，而无法从摘要中恢复出任何的消息，甚至根本就找不到任何与原信息相关的信息。
- 算法的输出结果是定长的
- 消息摘要是“伪随机”的
存在“碰撞”


## 公钥密码体制(public-key cryptography)
    由 公钥、私钥、加密解密算法 三部分组成，加密算法分为对称加密算法、非对称加密算法

### RSA：
- 加密：公钥加密，私钥解密的过程，称为“加密解密”。
- 签名： 私钥加密，公钥解密的过程，称为“签名校验”。

公钥是公开的，任何持有公钥的人都能解密私钥加密过的密文，
因此这个过程并不能保证消息的安全性，但是它却能保证消息来源的准确性和不可否认性



### 数字签名：
1. 用摘要算法对消息进行摘要
2. 再把摘要值用信源的私钥加密

发送者需要将原始信息和数字签名一同发送给接收者。而接收者在接收到原始信息和数字签名后，通过以下3步验证消息的真伪：

1. 把接收到的原始消息用同样的摘要算法摘要，形成“准签体”。
2. 对附加上的那段数字签名，使用预先得到的公钥解密。
3. 比较前两步所得到的两段消息是否一致。若不一致则表明传送的过程中一定出了问题，消息不可信。



## 数字证书Certificate
    数字证书是一个经证书授权（Certificate Authentication）中心数字签名的包含公钥拥有者信息以及公钥的文件，主要包含：
- 证书的发布机构（Issuer）
- 证书的有效期（Validity）
- 证书所有人的公钥（Public-Key）
- 证书所有人的名称（Subject）
- 证书所使用的签名算法（Signature algorithm）
- 证书发行者对证书的数字签名（Thumbprint）


## HTTPS
    https是ssl协议和http协议的组合，在进行http协议通讯之前会先通过ssl协议构建安全传输通道。

### 1. Client Hello:
明文请求服务器，请求内容包含：
- SSL/TLS版本号，
- 客户端支持的加密套件，
- 客户端生成的随机数random_C，
- 数据压缩算法
- extension拓展字段。

用于对称加密的秘钥由3部分构成：
- pre-master secret
- 客户端生成的随机数random_C
- 服务端生成的随机数random_S
    
    
extension拓展字段：
- 各种辅助信息，其中值得一提的是server_name，通常根据这个字段判断服务器是否支持SNI
    所谓SNI（Server Name Indicate）是为了解决多域名共享IP的情况。由于https用到的服务器证书是和域名绑定的，如果不支持SNI将有可能导致服务器下发证书校验失败，从而导致ssl握手失败。SNI支持在server_name字段里指定服务器域名，这样就不会导致因为下发错误证书导致的握手失败了。

### 2. Server Hello:
服务器这次其实有三个动作：
Server Hello：
- 服务端返回协商的信息结果：包
    - 括选择使用的协议版本 version，
    - 选择的加密套件cipher suite
    - 选择的压缩算法compression method、随机数random_S 等。
     
- server_certificates：服务器下发包含公钥的证书，用于身份验证和传递用于生成对称加密的秘钥的pre-master secret。
- server_hello_done：通知客户端Server Hello结束。

### 3. 客户端证书校验：
客户端验证证书的合法性，如果验证通过才会进行后续通信，否则根据错误情况不同做出提示和操作

- 证书合法性校验
    - 首先对证书的明文使用hash算法（证书提供）计算出证书的摘要信息。
    - 然后从本地预先植入的CA根证书中取出CA的公钥对证书的签名进行解密（证书的签名是使用的CA的私钥签名的，这里用到的是CA机构的公私钥对）
    - 解密后对比两个摘要信息是否一致，如果一致就可以判定证书合法，也就是公钥（我们自己的公钥）合法。
    - 证书是否吊销：有两类方式离线CRL与在线OCSP
    - 有效期expiry date：证书是否在有效时间范围。
    - 域名：核查证书域名是否与当前的访问域名匹配。

### 4. 客户端向服务端发送pre-master secret:
- client_key_exchange: 此时客户端再生成一段随机数，然后用服务器下发证书中的公钥对其签名，然后发送给服务器
    
    这里值得一提的是这段随机数的前两个字节是TLS的版本号，因为client_hello和server_hello的过程是明文的，攻击者通过抓包可以看到协商的TLS版本号，为了防止攻击者篡改TLS版本号（降低版本号以弱化安全性），因此在pre-master secret中放入TLS版本

- 生成对称加密秘钥
    - enc_key=Fuc(random_C, random_S, Pre-Master)
    - 使用三个伪随机值，function是一个生成伪随机值的函数
    - enc_key为最终对称加密使用的秘钥了

- change_cipher_spec: 通知服务器后续使用协商好的秘钥进行对称加密。

- encrypted_handshake_message: 
    
    - 验证对称加密，把之前通讯使用的参数的hash值揉到一块生成一个新的信息在用hash生成摘要信息
    - 使用enc_key和之前协商好的对称加密算法进行加密生成encrypt_message发给服务器。

### 5. 服务端解密，验证客户端encrypt_message:
- 服务端解密:
    拿到客户端发送来的加密后的pre-master secret，使用私钥解密，生成对称加密秘钥，用到的参数和方法和客户端一致。

- 验证客户端encrypt_message:
    使用对称秘钥解密客户端发来的encrypt_message，根据之前获取的请求参数的hash值与解密后的摘要信息对比，验证数据和秘钥的正确性。

- change_cipher_spec:
    验证通过后通知客户端当前秘钥可以使用，后续使用该秘钥进行通讯。

- encrypted_handshake_message：
    服务器也结合所有当前的通信参数信息生成一段数据并采用协商密钥与算法加密并发送到客户端。

### 6. 握手结束:
客户端计算所有接收信息的 hash 值，并采用协商密钥解密 encrypted_handshake_message，
验证服务器发送的数据和密钥，验证通过则握手完成。


## 总结：
- sl的握手首先客户端和服务端协商加密套件，约定后续用到的非对称，对称加密算法以及消息摘要算法，约定ssl版本
- 然后客户端验证服务器下发的证书，生成pre-master key再取出证书里的公钥进行加密，然后生成对称加密秘钥，同时使用加密秘钥生成encrypted_handshake_message统一发送给服务端
- 服务端用私钥解密取出pre-master key生成对称加密秘钥，解密encrypted_handshake_message验证秘钥和算法无误后也生成一个encrypted_handshake_message发送给客户端
- 客户端验证服务器发来的encrypted_handshake_message后握手结束。后续就使用对称加密来传输信息了

这套方案：
- 1.使用数字证书解决了公钥传递的问题，防止了中间人攻击替换秘钥
- 2.使用非对称加密的方式传递对称秘钥，有效防止了对称秘钥的泄露
